__Setup()
{
__var Reg;
  // Halt CPU immediately after reset
  __hwReset(0);
    // Disable WDT
  __writeMemory32(0x00000000,0x400040BC,"Memory");   // TIMCLK_CTRL = 0
  // Init clocks
  __writeMemory32(0x50<<2,0x40004050, "Memory");     // SYSCLK_CTRL - Switch to Main oscillator  
  // Set H divider and Per divider
  __writeMemory32(0x0000003D, 0x40004040, "Memory"); // PERIPH_CLK = PLL_CLK*1/16; 
                                                     // HCLK = PLL_CLK*1/2;
  // Set HPLL
  __writeMemory32(0x0001601E, 0x40004058, "Memory"); // HCLKPLL_CTRL OSC * 16 = 208MHz  
  do
  {
    Reg = __readMemory32(0x40004058, "Memory") & 1;  // HCLKPLL_CTRL_bit.LOOK
  }while(!Reg);
  
  // Switch to PLL output and out form the self-refresh of the SDRAM
  Reg = __readMemory32(0x40004044,"Memory");         // PWR_CTRL
  Reg &= ~((1 << 9) | (1 << 8));
  Reg |=   (1 << 2);
  __writeMemory32(Reg, 0x40004044, "Memory");
  Reg |=   (1 << 8);
  __writeMemory32(Reg, 0x40004044, "Memory");
  Reg &=  ~(1 << 8);
  __writeMemory32(Reg, 0x40004044, "Memory");
  
  // Disable 397 PLL
  __writeMemory32(0x00000002, 0x40004048, "Memory"); // PLL397_CTRL disable



  // Map IRAM at 0x00000000
  __writeMemory32(0x00000001, 0x40004014, "Memory"); // BOOT_MAP = 1;

  // Init Multilevel cell
  //FLASHCLK_CTRL_bit.MLC_NAND_ENA     = 1;   // MLC NAND Flash clock enable
  //FLASHCLK_CTRL_bit.SLC_MLC_SEL      = 0;   // Select MLC flash controller
  //FLASHCLK_CTRL_bit.INT_SEL          = 0;   // Disable the MLCNAND Flash controller interrupt
  //FLASHCLK_CTRL_bit.DMA_NAND_INT_ENA = 0;   // Disable NAND_DMA_REQ on NAND_INT
  //FLASHCLK_CTRL_bit.DMA_NAND_RnB_ENA = 0;   // Disable NAND_DMA_REQ on NAND_RnB
  __writeMemory32(0x00000002, 0x400040C8, "Memory");

  // unlocks the access to MLC NAND Controller configuration register
  //MLC_LOCK_PR = 0xA25E;
  __writeMemory32(0xA25E, 0x200B8044, "Memory");
  
  // 8 bit bus, 512, 3 adders cycles
  // Software Write protection disabled
  //MLC_ICR = 0;
  __writeMemory32(0x00000000, 0x200B8030, "Memory");

  // unlocks the access to MLC NAND Timing register
  //MLC_LOCK_PR  = 0xA25E;
  __writeMemory32(0xA25E, 0x200B8044, "Memory");
  
  //MLC_TIME_REG =( 3UL << 0 ) |  // Write pulse width (tWP)
  //              ( 2UL << 4 ) |  // Write high hold time (tWH)
  //              ( 3UL << 8 ) |  // Read pulse width (tRP)
  //              ( 2UL << 12) |  // Read high hold time (tREH)
  //              ( 4UL << 16) |  // Read high to high impedance (tRHZ)
  //              ( 2UL << 19) |  // Read/Write high to busy (tWB/tRB)
  //              ( 5UL << 24);   // nCE low to dout valid (tCEA)
  __writeMemory32(0x05142323, 0x200B8034, "Memory");
  // MLC_CEH = 1;
  __writeMemory32(1, 0x200B804C, "Memory");
  
  __writeMemory32((1UL<<19), 0x40028004, "Memory"); // P3_OUTP_SET_bit.GPO_19 = 1;  
  
}

execUserPreload()
{
  __message "----- NAND Flashloader init for debug -----";
  __Setup();
}

execUserFlashInit()
{
  __message "----- NAND Flashloader init -----";
  __Setup();
}

execUserFlashExit()
{
  __message "----- Reboot from NAND -----";
  __hwReset(2000); // Traget reset isn't connected on the board
}
